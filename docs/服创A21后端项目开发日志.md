# 服创A21后端项目开发日志

*written by lazy，polished by Gemini*



1.27

**阶段**：Spring Boot 基础 CRUD 实现

### 一、 项目初始化与环境配置

1. **工程创建**
   - 基于 Spring Boot 创建项目，构建工具选择 **Maven**。
   - 开发语言版本设定为 **Java 17** (LTS)。
   - Spring Boot 版本号选用 **3.5.5**。
2. **版本控制 (Git)**
   - 初始化本地 Git 仓库。
   - 建立与远程仓库的连接，完成首次提交。
3. **依赖管理 (Maven)**
   - **初始勾选**：MySQL Driver, Redis, Lombok。
   - **手动添加**：MyBatis-Plus, Spring Web 依赖 (参考既往配置，确保版本兼容性)。
   - **验证**：配置 `pom.xml` 后，成功启动 Spring Boot 应用并加载 MyBatis-Plus。

### 二、 数据库设计与连接配置

1. **数据库构建**
   - 根据业务需求设计表结构。
   - 在 DataGrip 中执行建库建表语句。
2. **配置文件 (`application.properties`)**
   - **数据库连接**：配置 URL、Username、Password。
   - **MyBatis-Plus 配置**：
     - 开启 **驼峰命名映射** (`map-underscore-to-camel-case`)：自动转换数据库下划线字段至 Java 驼峰属性。
     - 开启 **SQL 日志** (`stdOut`)：控制台打印 SQL 语句，便于调试。
   - **Redis 配置**：配置 Host、Port 等基础连接信息。

### 三、 核心 CRUD 模块开发

按照分层架构规范，依次完成以下模块编写：

1. **Entity (实体层)**：定义与数据库表对应的 POJO 类，配置主键策略与字段映射。
2. **Mapper (持久层)**：继承 MyBatis-Plus 的 `BaseMapper` 接口。
3. **Service (业务层)**：继承 `IService` 接口及 `ServiceImpl` 实现类。
4. **Controller (控制层)**：编写 RESTful 接口，处理 HTTP 请求。

### 四、 架构规范化与功能增强

为提升代码健壮性与可维护性，进行了以下优化：

1. **统一响应格式**
   - 创建 **状态码枚举** (`ResultCode`)。
   - 封装 **统一结果类** (`ApiResponse`)。
   - 重构 Controller，统一返回 `ApiResponse` 对象。
2. **分页功能**
   - 编写分页配置类 (`MybatisPlusConfig`)，注入 MyBatis-Plus 分页插件。
3. **自动化处理 (AOP)**
   - **自动填充**：实现 `MetaObjectHandler` 接口，自动处理 `createTime` 等字段的赋值。
   - **全局异常处理**：创建 `GlobalExceptionHandler`，使用 `@RestControllerAdvice` 统一捕获并处理系统异常。
4. **安全性与规范**
   - **参数校验**：引入 Validation 依赖，在实体类添加 `@NotBlank` 等注解，在 Controller 添加 `@Valid` 注解。
   - **消除魔法值**：引入枚举类 (`DataSourceEnum`, `TaskStatusEnum`) 替换代码中的硬编码数字。



1.28

**阶段**：数据工程、服务联调

### 一、 数据初始化 (Data Engineering)

为了避免后端服务测试时面对“空壳数据库”，优先进行了历史数据迁移。

1. **Python 脚本导入**
   - 编写 `import_data.py`，利用 **Pandas** 读取 CSV 文件，通过 **SQLAlchemy** 批量写入 MySQL。
   - **环境踩坑**：最初尝试在 IntelliJ IDEA 中配置全局 Python SDK，因环境路径问题失败；最终转向 **VS Code** 运行脚本（无需手动连接数据库插件）。
   - **数据清洗与优化**：
     - **脏数据处理**：脚本中增加了对 `NaN`、空字符串的处理。
     - **字段扩容**：运行过程中发现部分新闻内容超长，手动调整了数据库字段容量（如 `text` 类型）。

### 二、 前后端联调

完成了后端与前端对接的“桥梁”搭建，解决了跨域、文档和日志问题。

1. **跨域配置 (CORS)**
   - 修改 `WebMvcConfig`，重写 `addCorsMappings`，允许前端跨域访问接口。
2. **JSON 序列化规范**
   - 在 `application.properties` 中全局配置 **Jackson**，统一了时间格式 (`yyyy-MM-dd HH:mm:ss`) 和时区 (`GMT+8`)，避免前端解析时间戳麻烦。
3. **接口文档 (Knife4j)**
   - 引入 `knife4j` 依赖（解决了 Spring Boot 3 版本兼容性问题）。
   - 编写配置类，在 Controller 层添加 `@Tag` 和 `@Operation` 注解。
   - **复用性**：依赖版本组合验证通过，后续项目可直接复用，无需再次调试版本冲突。
4. **可观测性 (AOP)**
   - 编写 `WebLogAspect` 切面，实现对所有接口请求的 **入参、出参、耗时、IP** 的自动打印，极大方便了调试。
5. **接口测试**
   - 编写 `.http` 脚本（IntelliJ HTTP Client），替代 Postman 进行快速测试。

### 三、 业务功能扩展

1. **文件上传与静态资源映射**
   - 实现 `CommonController` 的图片上传接口。
   - **配置映射**：在 `WebMvcConfig` 中配置 `addResourceHandlers`，将本地磁盘路径 (`D:/forgery_uploads/`) 映射为 Web 路径，实现图片回显。
2. **统计看板**
   - 实现 `StatisticsController`，聚合查询新闻总数、谣言比例等，服务于前端首页大屏。

### 四、 ML 模型服务调用

为了实现 Java 后端与 Python 算法的解耦，采用了 **Microservice (微服务)** 通信模式。

1. **Mock 服务搭建 (FastAPI)**
   - 编写 `mock_ml_server.py`，使用 **FastAPI** 模拟算法服务。
   - **模拟策略**：接收请求 -> `sleep(2s)` 模拟显卡计算 -> 返回符合约定的假数据。此举使得在没有真实 AI 模型的情况下，也能独立测试后端流程。
2. **Java 客户端配置 (RestTemplate)**
   - 配置 `RestTemplate` Bean，相当于给 Spring Boot 装上了“电话机”，使其能发起 HTTP 请求。
3. **异步任务调度 (@Async)**
   - 改造 `submit` 接口：主线程只负责存库并返回 TaskID，使用 `@Async` 开启副线程异步调用 Python 服务。
   - **空值处理**：在 Java 端对 `title/content` 进行了判空处理，防止 Python 端 Pydantic 校验失败。
4. **接口契约**
   - 制定了接口规范，明确了 Input/Output 的 JSON 结构，方便后续 ML 成员接入真实模型。

### 五、 架构决策

1. **存储方案 (Storage)**
   - **当前**：本地磁盘存储。
   - **对比**：MinIO (分布式) vs 本地 vs 云 OSS。
   - **决策**：考虑到比赛 ROI (投入产出比)，当前阶段使用本地存储（部署时映射到服务器目录即可），无需引入 MinIO 增加运维复杂度。
2. **部署策略 (Deployment)**
   - **当前**：本地开发。
   - **计划**：比赛阶段购买云服务器，通过 Docker 或直接运行 Jar 包部署。届时只需修改少量配置 (`file.upload.path`, `ml.server.url`) 即可切换环境。
3. **安全架构 (Security)**
   - **舍弃**：Spring Security、复杂 RBAC。
   - **采用**：**Sa-Token**。
   - **理由**：相比手写 JWT，Sa-Token 更轻量、开发效率更高，且能快速实现注解鉴权等高级功能，符合比赛对展示效果的要求。



1.29

**阶段**：安全架构、性能优化与容器化部署

### 一、 安全架构 (Sa-Token)

为了满足比赛对系统安全性的要求，构建了基于 **Sa-Token** 的轻量级鉴权体系。

1. **用户体系构建**
   - 设计并创建 `sys_user` 表，完成对应的 Entity、Mapper 和 Service 层开发。
   - 实现了基础的用户注册与信息维护逻辑。
2. **鉴权集成**
   - **依赖引入**：引入 `sa-token-spring-boot-starter`。
   - **登录逻辑**：调用 `StpUtil.login(id)` 实现会话登录，后端自动注入 Token 到 Cookie/Header。
   - **路由拦截**：配置 `Sa-Token` 拦截器，对除了 `/auth/login` 和 `/doc.html` 以外的接口进行全量拦截，保护核心业务数据。
3. **异常处理优化**
   - **优雅降级**：在拦截器生效后，发现默认的 401 报错信息不明确。
   - **全局捕获**：在 `GlobalExceptionHandler` 中新增了对 `NotLoginException` 的捕获，将未登录异常转化为标准 JSON (`code: 401, message: "未登录"`) 返回，提升了前端交互体验。
4. **接口验证**
   - 编写 `.http` 测试脚本，通过先请求登录接口获取 Token，再将 Token 放入 Header 访问受保护接口，验证了鉴权逻辑的闭环。

### 二、 性能优化

针对高频查询场景进行了针对性优化，并在架构选型上做了取舍。

1. **架构决策**
   - **放弃消息队列**：经过对比赛 ROI（投入产出比）的分析，认为当前并发量级暂不需要引入 RabbitMQ 进行削峰填谷，避免过度设计增加运维成本。
2. **Redis 缓存实现**
   - **环境配置**：安装 Redis，编写 `RedisConfig` 配置类，定制了 Key-Value 的序列化方式（解决乱码问题）。
   - **业务改造**：开启 `@EnableCaching`，重构 `StatisticsService` 和 `NewsService`。
   - **效果验证**：利用 `@Cacheable` 注解，实现了“首次查询查库，二次查询读缓存”。经测试，热点数据的接口响应时间从几百毫秒级别下降至毫秒级。
3. **数据库索引优化**
   - 执行 `CREATE INDEX` 语句，为 `sys_news` 表的 `label` 和 `create_time` 字段添加索引。
   - 极大提升了分页查询和统计查询（如计算谣言比例）的检索速度。

### 三、 运维与部署 (DevOps)

完成了从本地开发环境到容器化部署环境的彻底改造。

1. **配置环境隔离 (Profiles)**
   - **配置文件拆分**：将 `application.properties` 拆解为三份：
     - `application.properties`：存放通用配置。
     - `application-dev.properties`：本地开发（连 localhost）。
     - `application-prod.properties`：容器部署（连 docker 容器名）。
   - **硬编码治理**：将 Java 代码中的本地路径（如图片上传路径）提取为 `@Value` 配置项。
   - **编码踩坑**：在 IDEA 设置中开启了 "Transparent native-to-ascii conversion"，解决了属性文件中中文注释或配置在运行时乱码的问题。
2. **项目结构清理**
   - 对项目文件进行了标准化整理，删除了冗余的 `import_data.py`（保留在 scripts 目录），忽略了 `.idea` 等 IDE 配置文件，使项目结构更清晰。
3. **数据库迁移 (Migration)**
   - **全量导出**：使用 DataGrip 的 "Export with mysqldump" 功能。
   - **路径修正**：解决了找不到 `mysqldump.exe` 和输出路径误填为文件夹的问题，成功导出了包含结构与数据（2万条新闻）的 `init.sql`，确保 Docker 启动即有数据。
4. **容器化基础设施**
   - **Nginx 网关**：配置 `nginx.conf`，实现了反向代理（转发 API 请求）和动静分离（直接由 Nginx 处理图片文件），隐藏了后端真实端口。
   - **Docker Compose**：编写 `Dockerfile` 和 `docker-compose.yml`，编排了 MySQL, Redis, Java Backend, Python ML, Nginx 五个容器。
5. **最终部署与网络修复**
   - **镜像加速**：在 Docker Desktop 安装过程中，遇到了拉取镜像超时的问题。通过修改 Docker Engine 配置，添加了国内镜像源（如 `docker.1panel.live`），解决了网络限制。
   - **一键运行**：执行 `docker compose up -d --build` 成功启动全套服务。
   - **成果展示**：通过浏览器访问 `localhost` 直接进入系统，验证了容器间通信及数据挂载的正确性。



补充：尝试使用 AI 创建简单页面实现真正的前后端联调，尝试多次未果，放弃。目前代码已修改为连接前端页面模式，ML部分仍维持模拟模式，优先保证系统全链路走通。
